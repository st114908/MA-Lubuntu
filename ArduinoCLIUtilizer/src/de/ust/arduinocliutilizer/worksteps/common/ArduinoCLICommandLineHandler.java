package de.ust.arduinocliutilizer.worksteps.common;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;

import org.yaml.snakeyaml.Yaml;

import de.ust.arduinocliutilizer.paths.DefaultConfigDirectoryAndFilePath;
import de.ust.arduinocliutilizer.worksteps.exceptions.NoArduinoCLIConfigFileException;
import projectfolderpathstorageplugin.ProjectFolderPathNotSetException;
import projectfolderpathstorageplugin.ProjectFolderPathStorage;

/**
 * @author muml
 * Handles the Command line/terminal calls.
 * The Results (exit code, normal response and error response)
 * get stored together in a ResponseFeedback object.
 * Windows support hasn't been tested since some of MUMLs files
 * only have different Capitalization in their names which 
 * is not compatible with default Windows storage setting.
 * Which means that there haven't been any performed tests under windows.
 */
public class ArduinoCLICommandLineHandler implements DefaultConfigDirectoryAndFilePath {
	// Static in order to only read once.
	private static boolean arduinoCLIPathSetInPathEnvironment;
	private static String arduinoCLIDirectory; // By default /home/muml/ArduinoCLI
	private static String potentialArduinoCLIPathCommand;
	private static boolean isWindows;

	public ArduinoCLICommandLineHandler()
			throws IOException, NoArduinoCLIConfigFileException, ProjectFolderPathNotSetException {
		Path projectPathOfSelectedFile = ProjectFolderPathStorage.projectFolderPath;
		if (ProjectFolderPathStorage.projectFolderPath == null) {
			throw new ProjectFolderPathNotSetException(
					"The static field projectFolderPath in ProjectFolderPathStorageArduinoCLIUtilizer has "
							+ "to be set to a complete file system path to the project's folder!");
		}
		if(arduinoCLIDirectory == null){ // Not yet read the config?
			Path completeConfigFilePath = projectPathOfSelectedFile.resolve(CONFIG_DIRECTORY_FOLDER_NAME)
					.resolve(CONFIG_FILE_NAME);
			if (Files.exists(completeConfigFilePath) && Files.isRegularFile(completeConfigFilePath)) {
	
			} else {
				throw new NoArduinoCLIConfigFileException("The ArduinoCLIUtilizer config file is missing!\n"
						+ "Generate one this way:\n" + "(Right click on a .zip, .ino or .hex file)/\n"
						+ "\"ArduinoCLIUtilizer\"/ \"GenerateArduinoCLIUtilizer config file\"");
			}
	
			// Read the config file.
			InputStream inputStream = new FileInputStream(completeConfigFilePath.toFile());
			Yaml yaml = new Yaml();
			Map<String, Object> loadedData = yaml.load(inputStream);
			arduinoCLIPathSetInPathEnvironment = (boolean) loadedData.get("arduinoCLIPathSetInPathEnvironment");
			arduinoCLIDirectory = (String) loadedData.get("arduinoCLIDirectory");
			inputStream.close();
	
			// System.out.println("ArduinoCLICommandLineHandler: Config read!");
			if (arduinoCLIPathSetInPathEnvironment) {
				potentialArduinoCLIPathCommand = "";
			} else {
				potentialArduinoCLIPathCommand = "export PATH=" + arduinoCLIDirectory + ":$PATH && ";
			}
			
			isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
			if(isWindows){
				System.out.println(
					"Warning! The ArduinoCLIUtilizer has been created for compiling code generated by the a modified"
					+ "MUML tool suite. Some of its files only have different Capitalization in their names which "
					+ "is not compatible with default Windows storage setting. "
					+ "Therefore no test under windows has been performed!");
			}
		}
	}

	public CallAndResponses doShellCommand(String commandSequence) throws IOException, InterruptedException {
		// Processbuilder is more intuitive to use than Runtime.
		ProcessBuilder processBuilder = new ProcessBuilder();
		boolean isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
		String commandSequenceWithPotentialArduinoCLIPathCommand = potentialArduinoCLIPathCommand + commandSequence; 
		if (isWindows) {
			processBuilder.command("cmd.exe", "/c", commandSequenceWithPotentialArduinoCLIPathCommand);
		} else {
			processBuilder.command("bash", "-c", commandSequenceWithPotentialArduinoCLIPathCommand);
		}
		Process proc = processBuilder.start();

		//Processbuilder has two streams for the text output.  
		BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		BufferedReader stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
		int exitCode = proc.waitFor();

		// Read the output from the command
		String currentNormalFeedback = null;
		String normalFeedback = "";
		while ((currentNormalFeedback = stdInput.readLine()) != null) {
			normalFeedback += currentNormalFeedback + "\n";
		}
		// Read any errors from the attempted command
		String currentErrorFeedback = null;
		String errorFeedback = "";
		while ((currentErrorFeedback = stdError.readLine()) != null) {
			errorFeedback += currentErrorFeedback + "\n";
		}

		return new CallAndResponses(commandSequenceWithPotentialArduinoCLIPathCommand, exitCode, normalFeedback, errorFeedback);
	}

}
