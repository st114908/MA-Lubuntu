package de.ust.arduinocliutilizer.worksteps.common;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;

import org.yaml.snakeyaml.Yaml;

import de.ust.arduinocliutilizer.paths.DefaultConfigDirectoryAndFilePath;
import de.ust.arduinocliutilizer.worksteps.exceptions.NoArduinoCLIConfigFileException;
import projectfolderpathstorageplugin.ProjectFolderPathNotSetException;
import projectfolderpathstorageplugin.ProjectFolderPathStorage;

/**
 * @author muml
 * Handles the Command line/terminal calls.
 * The Results (exit code, normal response and error response)
 * get stored together in a ResponseFeedback object.
 * Windows support hasn't been tested since some of MUMLs files
 * only have different Capitalization in their names which 
 * is not compatible with default Windows storage setting.
 * Which means that there haven't been any performed tests under windows.
 */
public class ArduinoCLICommandLineHandler implements DefaultConfigDirectoryAndFilePath {
	// Static in order to only read once.
	private static boolean arduinoCLIPathSetInPathEnvironment;
	private static String arduinoCLIDirectory; // By default /home/muml/ArduinoCLI
	private static String potentialArduinoCLIPathCommand;
	private static boolean isWindows;

	public ArduinoCLICommandLineHandler()
			throws IOException, NoArduinoCLIConfigFileException, ProjectFolderPathNotSetException {
		Path projectPathOfSelectedFile = ProjectFolderPathStorage.projectFolderPath;
		if (ProjectFolderPathStorage.projectFolderPath == null) {
			throw new ProjectFolderPathNotSetException(
					"The static field projectFolderPath in ProjectFolderPathStorageArduinoCLIUtilizer has "
							+ "to be set to a complete file system path to the project's folder!");
		}
		
		Path completeConfigFilePath = projectPathOfSelectedFile.resolve(CONFIG_DIRECTORY_FOLDER_NAME)
				.resolve(CONFIG_FILE_NAME);
		if (Files.exists(completeConfigFilePath) && Files.isRegularFile(completeConfigFilePath)) {

		} else {
			throw new NoArduinoCLIConfigFileException("The ArduinoCLIUtilizer config file is missing!\n"
					+ "Generate one this way:\n" + "(Right click on a .zip, .ino or .hex file)/\n"
					+ "\"ArduinoCLIUtilizer\"/ \"GenerateArduinoCLIUtilizer config file\"");
		}

		// Read the config file.
		InputStream inputStream = new FileInputStream(completeConfigFilePath.toFile());
		Yaml yaml = new Yaml();
		Map<String, Object> loadedData = yaml.load(inputStream);
		arduinoCLIPathSetInPathEnvironment = (boolean) loadedData.get("arduinoCLIPathSetInPathEnvironment");
		arduinoCLIDirectory = (String) loadedData.get("arduinoCLIDirectory");
		inputStream.close();

		// System.out.println("ArduinoCLICommandLineHandler: Config read!");
		if (arduinoCLIPathSetInPathEnvironment) {
			potentialArduinoCLIPathCommand = "";
		} else {
			potentialArduinoCLIPathCommand = "export PATH=" + arduinoCLIDirectory + ":$PATH && ";
		}
		
		isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
		if(isWindows){
			System.out.println(
				"Warning! The ArduinoCLIUtilizer has been created for compiling code generated by the a modified"
				+ "MUML tool suite. Some of its files only have different Capitalization in their names which "
				+ "is not compatible with default Windows storage setting. "
				+ "Therefore no test under windows has been performed!");
		}
		
		try {
			doShellCommand("arduino-cli config init");
		} catch (InterruptedException e) {
			System.out.println("Warning! The command execution for the generation of "
					+ "the internal config of the arduino-cli has been interrupted!");
		}
	}

	public CallAndResponses doShellCommand(String commandSequence) throws IOException, InterruptedException {
		// Processbuilder is more intuitive to use than Runtime.
		ProcessBuilder processBuilder = new ProcessBuilder();
		boolean isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
		String commandSequenceWithPotentialArduinoCLIPathCommand = potentialArduinoCLIPathCommand + commandSequence; 
		if (isWindows) {
			processBuilder.command("cmd.exe", "/c", commandSequenceWithPotentialArduinoCLIPathCommand);
		} else {
			processBuilder.command("bash", "-c", commandSequenceWithPotentialArduinoCLIPathCommand);
		}
		Process proc = processBuilder.start();

		//Processbuilder has two streams for the text output.  
		BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		BufferedReader stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
		int exitCode = proc.waitFor();

		// Read the output from the command
		String currentNormalFeedback = null;
		String normalFeedback = "";
		while ((currentNormalFeedback = stdInput.readLine()) != null) {
			normalFeedback += currentNormalFeedback + "\n";
		}
		// Read any errors from the attempted command
		String currentErrorFeedback = null;
		String errorFeedback = "";
		while ((currentErrorFeedback = stdError.readLine()) != null) {
			errorFeedback += currentErrorFeedback + "\n";
		}

		return new CallAndResponses(commandSequenceWithPotentialArduinoCLIPathCommand, exitCode, normalFeedback, errorFeedback);
	}

}
